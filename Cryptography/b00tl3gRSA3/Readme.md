Challenge
```
Why use p and q when I can use more? Connect with nc jupiter.challenges.picoctf.org 4557.
```

Connect to it gave me the values
```
c: 27500395872454480243726910776980922047533538794839405313363578171129574848150079538395080259133226619246433108978680119609666821803220596551218370509635854769044854350930758878542825880247948059438563726140538925579046194766125935612698091251892761494576183020859626558142053063103127545352057843594963305732425745603954729971372337883619967929
n: 39128952904982414107821588454382997587704569615019244453798187458692761562998453564962998350708958567388486484219130624393123444897620559140951722893223155929897645279273155098233366272355165437308066487903733915516229996489706121823462005605779509973920933808421787939495695507918693569453618726448946774327170757763129442115224698039238809427
e: 65537
```

I tried factordb ```http://factordb.com/index.php``` for the factors of n it gave me many factors so i searched for factors other than p and q in RSA and got this link
```https://crypto.stackexchange.com/questions/74891/decrypting-multi-prime-rsa-with-e-n-and-factors-of-n-given``` So i used factordb's factors but it didn't worked for me
it didn't gave me all factors. So for large numbers i found ```https://www.alpertron.com.ar/ECM.HTM``` and it gave me all factors. I wrote a python script for this

```
#!/usr/bin/env python3

from Crypto.Util.number import inverse
c = 27500395872454480243726910776980922047533538794839405313363578171129574848150079538395080259133226619246433108978680119609666821803220596551218370509635854769044854350930758878542825880247948059438563726140538925579046194766125935612698091251892761494576183020859626558142053063103127545352057843594963305732425745603954729971372337883619967929
n = 39128952904982414107821588454382997587704569615019244453798187458692761562998453564962998350708958567388486484219130624393123444897620559140951722893223155929897645279273155098233366272355165437308066487903733915516229996489706121823462005605779509973920933808421787939495695507918693569453618726448946774327170757763129442115224698039238809427
e = 65537


phi = (9198618449-1) * (9231485239-1) * (9258866843-1) * (9368892119-1) * (9609125549-1) * (10124062561-1) * (10366517717-1) * (10537203847-1) * (10698386513-1) * (10876388417-1) * (10887200869-1) * (11335526567-1) * (11338421267-1) * (11577542939-1) * (11850068777-1) * (11930983993-1) * (12239128567-1) * (12433438403-1) * (13690426579-1) * (14498298961-1) * (14625475913-1) * (15186292727-1) * (15216659123-1) * (15237022903-1) * (15419976521-1) * (15631449373-1) * (15793257583-1) * (15834411317-1) * (15895452847-1) * (16034990989-1) * (16266509477-1) * (16760835433-1) * (16888988933-1) * (17044531117-1) 
d = inverse(e, phi)
m = pow(c,d,n)
print(bytes.fromhex(hex(m)[2:]).decode('utf-8'))
```
This is not the robust solution for multi-prime RSA, I just used my IDE for finding and replacing characters which took me 20secs for making the phi line so I used this only
for decoding. After running the script you will get the flag

flag: ```picoCTF{too_many_fact0rs_4025135}```
